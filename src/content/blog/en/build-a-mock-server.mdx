---
title: 'How to build a mock server'
date: '2024-10-13'
cover: ''
tag: ['Hono', 'Tool', 'Faker.js']
---

There are many SaaS services that provide online mock services, like Apifox, Insomnia, etc.  
However, they are first and foremost API design tools, and then mock services.  

If you only need to provide interfaces for demos or create fake data before backend development is complete, these tools are too heavy.  
More importantly, they only provide self-hosting services for commercial users, which is not very friendly for ordinary developers.

I will introduce how to implement your own online mock service using Node.js, MongoDB, and Faker.js.  

> You can also find the project code on [https://github.com/Ray-D-Song/faker-server](https://github.com/Ray-D-Song/faker-server).  
> online demo: https://faker-preview.jenrays.com/ read-only permission key: 1234

## Feature Goals
1. Create, edit, and delete interface data
2. Basic authentication capabilities

## Data Structure
First of all, what we want to implement is not a json server. You can't let users input a json content and then return it directly, as this would be meaningless.

The design reference should be similar to Apifox, where users can input the interface path, method, and description on the interface, and then create a structured interface return value definition.

<img src="https://r2.ray-d-song.com/2024/10/d5a32b26a5d7fd54947eded8cb89b5f2.png"/>

Based on RESTful interfaces, the data structure should be a tree with a root node `root`. The type of the root node can be either `object` or `array`.
If it's an array, there needs to be a field to record the target length of the array, which is very useful when mocking paginated interfaces.

Next, we need to consider how to define each child node, which is the key-value structure in json.

For example, if a user needs a user information interface `/user` that returns a user information object:
```json
{
  "name": "Ray",
  "age": 20,
  "grade": "junior",
  "hobbies": ["reading", "traveling", "coding"]
}
```

Json's key is input directly by the user, and the value is generated by faker.js, so we need to record the corresponding faker method for each key.
For example, the method to generate a human name is `faker.name.fullName`.

The grade field's value is `junior`, `middle`, `high`, which is an enumeration value. We need to convert the user's input value to the standard value.
So we need to record the optional value list and the data type of the return value itself. Because sometimes we need numbers 1, 2, 3 instead of strings "1", "2", "3".

Since there are numbers, there must also be maximum and minimum values. For example, the age cannot be generated as 1000 years old.

Based on the above analysis, we can define each node of the tree:
```ts
// Define each node of the tree
interface Node {
  // The key of the attribute, such as name in name: 'Ray'
  key: string
  // The type of the attribute, such as string
  type: string
  // The faker method to generate the value, such as faker.name.fullName
  mock: string
  // The optional value list, used when the type is enum
  enum?: string[]
  // The minimum value, used when the type is number
  min?: number
  // The maximum value, used when the type is number
  max?: number
}
```

## Function Implementation
Designing the data structure is already half the battle.  
Next, we need to consider how to implement these functions.  

The service is divided into two parts:
1. Data management, including creating, editing, and deleting interface data `/api/*`
2. Interface mock, returning corresponding mock data according to the interface path and method `/mock/*`

### Data Management CRUD
What we need to store in the database is the interface information, including the path, method, description, and response definition.
```ts
interface Api {
  // API ID
  id: string
  // API path
  path: string
  // API method
  method: string
  // API description
  description: string
  // API response definition
  data: Node[]
}
```

You can use any database you like, but I recommend using MongoDB because it natively supports tree structures.

I chose Hono as the web framework, a lightweight framework that supports multiple serverless platforms.  

```ts
const crudApp = new Hono<{ Bindings: Bindings }>()

crudApp.post('/create', async (c) => {
  // Read the interface data from the request body
  const api = await c.req.json<Api>()
  // Get the database from ctx
  const db = c.get('db')
  const collection = db.collection<Api>('apis')

  // Check if the interface already exists
  const existingApi = await collection.findOne({
    path: api.path, method: api.method, deleted: { $ne: true }
  })

  // If the interface already exists, return an error
  if (existingApi) {
    return c.json({ error: 'API already exists' }, 400)
  }

  // Insert the interface data into the database
  const result = await collection.insertOne(api)

  // If the insertion is successful, return the created interface data
  if (result.acknowledged) {
    const createdApi = await collection.findOne({ _id: result.insertedId })
    return c.json(createdApi, 201)
  }

  // If the insertion fails, return an error
  return c.json({ error: 'Failed to create API' }, 500)
})
```

If you use `express`, the core code is exactly the same, except for the routing organization method.

### Interface Mock
The processing flow for mock interfaces is as follows:

1. Receive requests starting with `/mock`, for example `GET /mock/user`
2. Use the request method and path as query conditions to search for corresponding interface data in the database
3. Generate mock data based on the data structure in the interface definition and return it

The most crucial part is the third step: how to generate mock data based on the data structure in the interface definition.
Because it's a tree structure, recursive processing is needed.
At the same time, there are many details to consider, such as randomly selecting a value for enumeration types, converting the type if it's 'number' before returning, and considering maximum and minimum values for numeric types.

We'll approach this problem from the bottom up. First, we'll call faker.js to generate data based on the value of the mock field.
Let's write a fake method:

```ts
interface FakeOptions {
  min?: number
  max?: number
}

/**
 * @param key - For example, faker.name.fullName
 * @param options - For example, { min: 18, max: 60 }
 */
function fake(key: string, options?: FakeOptions) {
  // Split the string by dots
  const parts = key.split('.')
  let currentObject: any = faker

  for (const part of parts) {
    // Check if the current object has this method
    if (typeof currentObject[part] === 'function') {
      let result: any
      // If there are additional options, pass them when calling the method
      if (options) {
        result = currentObject[part](options)
      } else {
        result = currentObject[part]()
      }
      // Check if the result is BigInt, if so, convert it to string, otherwise JSON.stringify will throw an error
      return typeof result === 'bigint' ? result.toString() : result
    } else if (currentObject[part] !== undefined) {
      // Continue processing the next level
      currentObject = currentObject[part]
    } else {
      throw new Error(`Failed to generate mock data: ${key}`)
    }
  }

  throw new Error(`Failed to generate mock data: ${key}`)
}
```

Then we can process the response body according to the node tree.

```ts
/**
 * Process the response body
 * @param body - The node tree
 */
function processResBody(body: Node[]) {
  // Process single node logic
  function processNode(node: Node) {
    if (node.value !== undefined && node.value.trim() !== '') {
      // If a non-empty specific value is set, split it into an optional value array
      const options = node.value.split('^').map((v) => v.trim())
      // Randomly select a value
      const selectedValue = options[Math.floor(Math.random() * options.length)]
      // Convert the selected value to the corresponding type
      switch (node.type) {
        case 'number':
          return Number(selectedValue)
        case 'boolean':
          return selectedValue.toLowerCase() === 'true'
        case 'null':
          return null
        case 'object':
        case 'array':
          try {
            return JSON.parse(selectedValue)
          } catch {
            console.warn(`Failed to parse ${node.key} value as ${node.type}, using original string`)
            return selectedValue
          }
        default:
          return selectedValue
      }
    }

    // Process different types of nodes
    switch (node.type) {
      // Object type, recursively process each child node
      case 'object':
        const obj: { [key: string]: any } = {}
        node.children?.forEach((child) => {
          obj[child.key] = processNode(child)
        })
        return obj
      // Array type, generate the corresponding number of child nodes
      case 'array':
        const arr: any[] = []
        const length = node.length || 1
        for (let i = 0; i < length; i++) {
          arr.push(processNode(node.children?.[0] || {
            key: 'item',
            type: 'string',
            mock: 'string.alphanumeric',
          }))
        }
        return arr
      // Other types call fake to generate data
      case 'number':
        let options: FakeOptions = {}
        if (node.min) options.min = Number(node.min)
        if (node.max) options.max = Number(node.max)
        return fake(node.mock, options)
      case 'string':
      case 'boolean':
        return fake(node.mock)
      case 'null':
        return null
      case 'any':
        return fake('datatype.json')
      default:
        return undefined
    }
  }

  // Start processing from the root node
  return processNode(body[0])

}
```

The core logic of `processResBody` is self-recursive, processing different types of nodes according to different types.  
Next, we need to integrate the `processResBody` method into the mock interface routing.  

### Basic Authentication
Since it's a web service, you can't let anyone create, delete, or modify interfaces.  

Here, we don't introduce additional complexity, such as multi-tenancy, directly using a `KEY` field for authentication.

Specifically, when the service is first started, a configuration file `.env` is generated, containing a `KEY` field, whose value is a uuid.  
The client sets a custom `Faker-Server-Key` request header, which is used to verify its value when making requests.  
Every time the service is started, it reads this file, so every time the `KEY` is modified, the service needs to be restarted.  

This can also be extended to read-only `KEY`, `ADMIN KEY`, `ACCESS KEY`, etc.  

```ts
// Generate default configuration
function generateDefaultConfig() {
  // Check if the configuration directory exists
  if (!fs.existsSync(configDir)) {
    fs.mkdirSync(configDir, { recursive: true })
  }
  
  // Check if the configuration file exists, if not, create it
  if (!fs.existsSync(configFile)) {
    // Generate three UUIDs as KEY
    const accessKey = crypto.randomUUID()
    const adminKey = crypto.randomUUID()
    const readonlyKey = crypto.randomUUID()
    const defaultConfig = `
# Server Port
PORT=3000

# Access /mock/* API
ACCESS_KEY=${accessKey}

# If true, the server will allow public access to the /mock/* API
# /api/* will continue to require authentication
PUBLIC_ACCESS=false

# ADMIN_KEY is used to access the web page and modify the data
ADMIN_KEY=${adminKey}

# READONLY_KEY can access the web page, but cannot modify the data
READONLY_KEY=${readonlyKey}

# MongoDB URL
MONGO_URL=mongodb://admin:password@localhost:27017?authSource=admin
`.trim()

    // Write the default configuration to the file
    fs.writeFileSync(configFile, defaultConfig)
    console.log('Created default configuration file at:', configFile)
  }
}
```

### Summary
This is not a step-by-step tutorial, but rather an idea.  
You can refer to [https://github.com/Ray-D-Song/faker-server](https://github.com/Ray-D-Song/faker-server) for the specific implementation.  

