---
title: 'Building React and Vue Components Simultaneously with Mitosis'
date: '2024-08-09'
cover: ''
tag: ['frontend', 'React', 'Vue']
---

I recently wrote about the [UnoCSS icon selector](/zh-cn/blog/unocss-icon-viewer) and wanted to create a library that can be used in both React and Vue.

My initial thought was to use Web Components. However, the drawback is that it requires separate adaptation code for Vue and React beyond the core logic.  
For some smaller requirements, the cost of writing adaptation code may be higher than manual adaptation.

That's when I stumbled upon this weird thing called `Mitosis`.  
Mitosis, named after the biological process of cell division, can compile components into code for multiple frameworks, including React, Vue, Qwik, Solid, Angular, and Svelte.

Similar to UnoCSS, it's frontend compilation alchemy.

## Creating a Project
```bash
npm create @builder.io/mitosis@latest
```
When running the command, there are configurable options. When selecting the output target, only React, Svelte, and Qwik are available.  
To add Vue support, modify the `targets` field in `library/mitosis.config.cjs`:
```js
"targets": [
  "react",
  "vue",
],
```
The project comes with two examples, `todo-app.lite.tsx` and `autocomplete.lite.tsx`. Try running them:
```bash
cd library
npm run build

# Mitosis: react: generated 2 components, 1 regular files.
# Mitosis: vue: generated 2 components, 1 regular files.
# Mitosis: generation completed.
```
You will see that the `/library/package` directory correctly generates React and Vue components.

## Writing Components
Mitosis components have the `.lite.tsx` suffix and use JSX syntax with their own API.  
> Due to compiler limitations, the framework only supports the `export default function` syntax and does not allow defining and exporting later.

### State Management
Component state is managed using the `useStore` hook, and it must be named `state` (another compiler restriction).  
```tsx
export default function MyComponent() {
  // ...
  const state = useStore({
    iconList: [],
  })
}
```
You can pass any parameters to the store, but if you need a value that requires expression calculation, you need to write a `getter`:
```tsx
const state = useStore({
  iconList: [],
  get outlineIcon() {
    return this.iconList.filter(icon => icon.endsWith('-outline'))
  },
})
```

It also supports the `useState` API, used similarly to React:
```tsx
const [count, setCount] = useState(0)
```

### Styling
Mitosis uses the `css` attribute on tags to write `camelCase` styles. You can even write CSS queries like this:
```tsx
<div
  css={{
    marginTop: '10px',
    '@media (max-width: 500px)': {
      marginTop: '0px',
    },
  }}
/>
```
Additionally, the compiled result provides style isolation (which React itself still doesn't support ðŸ˜‚).

## Flow Control
To abstract away differences between frameworks, Mitosis implements its own flow control using specific tags. Here is a comparison table, for more details refer to the [documentation](https://mitosis.builder.io/docs/components/):  
| Mitosis | React | Vue |
| --- | --- | --- |
| `<Show>` | `if` | `v-if` |
| `<For>` | `map` | `v-for` |

## Integrating Other Libraries
Since Mitosis is not a frontend framework but a compiler, it does not come with webpack or Vite integration.  
For example, to use UnoCSS, you can only use `uno cli`, watch for file changes, compile CSS files, and then import them.

However, there is a better approach. Essentially, Mitosis is just a transformation pipeline, so all we need to do is set the `environment for the output`. After Mitosis completes the conversion, other tools take over for packaging.  
The final process of writing components becomes:
1. Write Mitosis components
2. Compile using `npm run build`, output to a Vite environment
3. Use a bundler like `vite` to package the final product for npm release

You can refer to this project as an example: [unocss-icon-viewer](https://github.com/Ray-D-Song/unocss-icon-viewer).

There are some key points to note, such as setting `jsxImportSource` to `@builder.io/mitosis` in the tsconfig of Mitosis.  
This may cause JSX type errors when building libraries like React or Solid.  
The solution is to configure esbuild and ets plugins in Vite to dynamically modify `compilerOptions`.
```ts
export default defineConfig({
  plugins: [
    // ...
    dts({
      outDir: 'dist',
      include: 'packages/*/src/**',
      compilerOptions: {
        jsxImportSource: 'react',
      }
    }),
  ],
  // ...
  esbuild: {
    tsconfigRaw: {
      compilerOptions: {
        jsxImportSource: 'react',
      }
    }
  }
})
```

## Defects
Mitosis is a decent solution, but it also has its flaws, such as:
* Inability to control product quality, the generated code is not the optimal solution
* Strange rules, such as props cannot be destructured, only `props.xxx` can be used, in other words, the compiler is too weak
* Writing source code => compiling to the packaging environment => running the testing environment involves at least 3 watches and environments, which is too complex
