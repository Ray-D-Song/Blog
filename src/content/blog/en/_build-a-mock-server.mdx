---
title: 'How to build a mock server'
date: '2024-10-13'
cover: ''
tag: ['Hono', 'Tool', 'Faker.js']
---

There are many SaaS services that provide online mock services, like Apifox, Insomnia, etc.  
However, they are first and foremost API design tools, and then mock services.  

If you only need to provide interfaces for demos or create fake data before backend development is complete, these tools are too heavy.  
More importantly, they only provide self-hosting services for commercial users, which is not very friendly for ordinary developers.

I will introduce how to implement your own online mock service using Node.js, MongoDB, and Faker.js.  

> You can also find the project code on [https://github.com/Ray-D-Song/faker-server](https://github.com/Ray-D-Song/faker-server).

## Feature Goals
1. Create, edit, and delete interface data
2. Basic authentication capabilities

## Data Structure
First of all, what we want to implement is not a json server. You can't let users input a json content and then return it directly, as this would be meaningless.

The design reference should be similar to Apifox, where users can input the interface path, method, and description on the interface, and then create a structured interface return value definition.

<img src="https://r2.ray-d-song.com/2024/10/d5a32b26a5d7fd54947eded8cb89b5f2.png"/>

Based on RESTful interfaces, the data structure should be a tree with a root node `root`. The type of the root node can be either `object` or `array`.
If it's an array, there needs to be a field to record the target length of the array, which is very useful when mocking paginated interfaces.

Next, we need to consider how to define each child node, which is the key-value structure in json.

For example, if a user needs a user information interface `/user` that returns a user information object:
```json
{
  "name": "Ray",
  "age": 20,
  "grade": "junior",
  "hobbies": ["reading", "traveling", "coding"]
}
```

Json's key is input directly by the user, and the value is generated by faker.js, so we need to record the corresponding faker method for each key.
For example, the method to generate a human name is `faker.name.fullName`.

The grade field's value is `junior`, `middle`, `high`, which is an enumeration value. We need to convert the user's input value to the standard value.
So we need to record the optional value list and the data type of the return value itself. Because sometimes we need numbers 1, 2, 3 instead of strings "1", "2", "3".

Since there are numbers, there must also be maximum and minimum values. For example, the age cannot be generated as 1000 years old.

Based on the above analysis, we can define each node of the tree:
```ts
// Define each node of the tree
interface Node {
  // The key of the attribute, such as name in name: 'Ray'
  key: string
  // The type of the attribute, such as string
  type: string
  // The faker method to generate the value, such as faker.name.fullName
  mock: string
  // The optional value list, used when the type is enum
  enum?: string[]
  // The minimum value, used when the type is number
  min?: number
  // The maximum value, used when the type is number
  max?: number
}
```

## Function Implementation
Designing the data structure is already half the battle.  
Next, we need to consider how to implement these functions.  

The service is divided into two parts:
1. Data management, including creating, editing, and deleting interface data `/api/*`
2. Interface mock, returning corresponding mock data according to the interface path and method `/mock/*`

### Data Management CRUD
What we need to store in the database is the interface information, including the path, method, description, and response definition.
```ts
interface Api {
  // API ID
  id: string
  // API path
  path: string
  // API method
  method: string
  // API description
  description: string
  // API response definition
  data: Node[]
}
```

You can use any database you like, but I recommend using MongoDB because it natively supports tree structures.

I chose Hono as the web framework, a lightweight framework that supports multiple serverless platforms.  

```ts
const crudApp = new Hono<{ Bindings: Bindings }>()

crudApp.post('/create', async (c) => {
  // Read the interface data from the request body
  const api = await c.req.json<Api>()
  // Get the database from ctx
  const db = c.get('db')
  const collection = db.collection<Api>('apis')

  // Check if the interface already exists
  const existingApi = await collection.findOne({
    path: api.path, method: api.method, deleted: { $ne: true }
  })

  // If the interface already exists, return an error
  if (existingApi) {
    return c.json({ error: 'API already exists' }, 400)
  }

  // Insert the interface data into the database
  const result = await collection.insertOne(api)

  // If the insertion is successful, return the created interface data
  if (result.acknowledged) {
    const createdApi = await collection.findOne({ _id: result.insertedId })
    return c.json(createdApi, 201)
  }

  // If the insertion fails, return an error
  return c.json({ error: 'Failed to create API' }, 500)
})
```

If you use `express`, the core code is exactly the same, except for the routing organization method.

### Interface Mock
The processing flow for mock interfaces is as follows:

1. Receive requests starting with `/mock`, for example `GET /mock/user`
2. Use the request method and path as query conditions to search for corresponding interface data in the database
3. Generate mock data based on the data structure in the interface definition and return it

The most crucial part is the third step: how to generate mock data based on the data structure in the interface definition.
Because it's a tree structure, recursive processing is needed.
At the same time, there are many details to consider, such as randomly selecting a value for enumeration types, converting the type if it's 'number' before returning, and considering maximum and minimum values for numeric types.

We'll approach this problem from the bottom up. First, we'll call faker.js to generate data based on the value of the mock field.
Let's write a fake method:

```ts
interface FakeOptions {
  min?: number
  max?: number
}

/**
 * @param key - For example, faker.name.fullName
 * @param options - For example, { min: 18, max: 60 }
 */
function fake(key: string, options?: FakeOptions) {
  // Split the string by dots
  const parts = key.split('.')
  let currentObject: any = faker

  for (const part of parts) {
    // Check if the current object has this method
    if (typeof currentObject[part] === 'function') {
      let result: any
      // If there are additional options, pass them when calling the method
      if (options) {
        result = currentObject[part](options)
      } else {
        result = currentObject[part]()
      }
      // Check if the result is BigInt, if so, convert it to string, otherwise JSON.stringify will throw an error
      return typeof result === 'bigint' ? result.toString() : result
    } else if (currentObject[part] !== undefined) {
      // Continue processing the next level
      currentObject = currentObject[part]
    } else {
      throw new Error(`Failed to generate mock data: ${key}`)
    }
  }

  throw new Error(`Failed to generate mock data: ${key}`)
}
```

Then we can process the response body according to the node tree.
```ts

```